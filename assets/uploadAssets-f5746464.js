import{c5 as m,at as y,ax as l,cB as M,ar as c,hE as J,hC as O,hF as G,as as k,bz as V,hA as W,dm as K,dq as x,dp as A,fl as U,hy as Q,fm as X,hG as Y}from"./index-080e108a.js";const N=1e6,D=20*N,Z=2e9,_=3;async function ee({data:e,name:a,description:t},s,r){let o=null;try{const n=m(s,"uploads"),i=m(n,"info"),{data:u}=await y(i,{query:{f:"json"},responseType:"json"});l(r);const p=M(s),d=u.maxUploadFileSize*N,w=p?Z:d,T=p?Math.min(D,d):D;if(e.size>w)throw new Error("Data too large");const P=m(n,"register"),{data:b}=await y(P,{query:{f:"json",itemName:a,description:t},responseType:"json",method:"post"});if(l(r),!b.success)throw new Error("Registration failed");const{itemID:R}=b.item;o=m(n,R);const C=m(o,"uploadPart"),B=Math.ceil(e.size/T),h=new Array;for(let f=0;f<B;++f)h.push(e.slice(f*T,Math.min((f+1)*T,e.size)));const g=h.slice().reverse(),F=new Array,L=async()=>{for(;g.length!==0;){const f=h.length-g.length,E=g.pop(),$=new FormData;$.append("f","json"),$.append("file",E),$.append("partId",`${f}`);const{data:H}=await y(C,{timeout:0,body:$,responseType:"json",method:"post"});if(l(r),!H.success)throw new Error("Part upload failed")}};for(let f=0;f<_&&g.length!==0;++f)F.push(L());await Promise.all(F);const z=m(o,"commit"),{data:j}=await y(z,{query:{f:"json",parts:h.map((f,E)=>E).join(",")},responseType:"json",method:"post"});if(l(r),!j.success)throw new Error("Commit failed");return j.item}catch(n){if(o!=null){const i=m(o,"delete");await y(i,{query:{f:"json"},responseType:"json",method:"post"})}throw n}}async function $e(e,a,t){return e.length?Promise.all(e.map(s=>te(s,a,t))):[]}async function te(e,{layer:a,ongoingUploads:t},s){const r=t.get(e);if(r)return r;if(!we(a))throw new c(`${a.type}-layer:upload-failure`,"Layer does not support asset uploads.",new Error);if(ae(e,a))return e;const o=se(e,a,s);t.set(e,o);try{await o}finally{t.delete(e)}return e}function ae(e,a){const{parsedUrl:t}=a;return t!=null&&e.metadata.externalSources.some(s=>J(s,t))}async function se(e,a,t){const{metadata:s}=e,{displaySource:r}=s,o=v(r==null?void 0:r.source,a),n=!!o,i=s.externalSources.length>0,u=n?ne(o,a,t):i?oe(e,a,t):re(e,a,t),p=await u;return l(t),e.addExternalSources([p]),e}async function ne(e,a,t){return{source:await S(e,a,t),original:!0}}async function oe(e,a,t){const s=I(a),{externalSources:r}=e.metadata,o=le(r,a);if(!o)throw new c(`${a.type}-layer:upload-failure`,"Could not find an external source that is supported by the service.",new Error);const n=await S(o,a,t);return e.addExternalSources([{source:n,original:!0}]),{source:await ye(n,a,s)}}async function re(e,a,t){const s=ie(e,a,t);return{source:await q([s],a,t),extent:e.extent.clone(),original:!0}}async function ie(e,a,t){const s=I(a),r=await e.load(t),o=await r.toBinaryGLTF({ignoreLocalTransform:!0});l(t);const n=await o.buffer();return l(t),{blob:new Blob([n.data],{type:n.type}),assetName:`${O()}.glb`,assetType:s}}function le(e,a){for(const t of e){const s=v(t.source,a);if(s)return s}return null}function v(e,a){if(!e)return null;const{infoFor3D:{supportedFormats:t,editFormats:s}}=a,r=Y(e),o=new Array;let n=!1;for(let i=0;i<r.length;++i){const u=ue(r[i],t);if(!u)return null;s.includes(u.assetType)&&(n=!0),o.push(u)}return n?o:null}function ue(e,a){const t=G(e,a);return t?{asset:e,assetType:t}:null}async function S(e,a,t){return q(e.map(s=>ce(s,t)),a,t)}async function q(e,a,t){const s=await Promise.all(e.map(async o=>{const n=pe(await o,a,t);return l(t),n}));l(t);const{uploadResults:r}=await de(s.map(({item:o})=>o),a,t);return l(t),e.map((o,n)=>fe(s[n],r[n],a))}async function ce(e,a){const{asset:t,assetType:s}=e;if(t instanceof File)return{blob:t,assetName:t.name,assetType:s};const r=await t.toBlob(a);return l(a),{blob:r,assetName:t.assetName,assetType:s}}async function pe(e,a,t){const{blob:s,assetType:r,assetName:o}=e;let n=null;try{const i=await ee({data:s,name:o},a.url,t);l(t),n={assetType:r,assetUploadId:i.itemID}}catch(i){k(i),V.getLogger("esri.layers.graphics.sources.support.uploadAssets").warnOnce(`Service ${a.url} does not support the REST Uploads API.`)}if(!n){const i=await W(s);if(l(t),!i.isBase64)throw new c(`${a.type}-layer:uploadAssets-failure`,"Expected gltf data in base64 format after conversion.",new Error);n={assetType:r,assetData:i.data}}if(!n)throw new c(`${a.type}-layer:uploadAssets-failure`,"Unable to prepare uploadAsset request options.",new Error);return{item:n,assetName:o}}async function de(e,a,t){const s=await y(m(a.parsedUrl.path,"uploadAssets"),{timeout:0,query:{f:"json",assets:JSON.stringify(e)},method:"post",responseType:"json"});if(l(t),s.data.uploadResults.length!==e.length)throw new c(`${a.type}-layer:uploadAssets-failure`,`Bad response. Uploaded ${e.length} items and received ${s.data.uploadResults.length} results.`,new Error);return s.data}function fe(e,a,t){const{success:s}=a;if(!s){const{error:p}=a;throw new c(`${t.type}-layer:upload-failure`,`Failed to upload mesh file ${e.assetName}. Error code: ${p.code}. Error message: ${p.messages}`,new Error)}const{assetHash:r}=a,{assetName:o,item:{assetType:n}}=e,{infoFor3D:{supportedFormats:i}}=t,u=K(n,i);if(!u)throw new c(`${t.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${n}, but it does not list it in its supported formats.`,new Error);return new x(o,u,[new A(`${t.parsedUrl.path}/assets/${r}`,r)])}async function ye(e,a,t){var p;const s=e.map(({assetName:d,parts:w})=>({assetName:d,assetHash:w[0].partHash})),r=(p=a.capabilities)==null?void 0:p.operations.supportsAsyncConvert3D,o={query:{f:"json",assets:JSON.stringify(s),transportType:"esriTransportTypeUrl",targetFormat:t,async:r},responseType:"json",timeout:0},n=m(a.parsedUrl.path,"convert3D"),i=(r?await me(n,o):await y(n,o)).data,{infoFor3D:{supportedFormats:u}}=a;return i.assets.map(d=>{const w=U(d.contentType,u);if(!w)throw new c(`${a.type}-layer:upload-failure`,`The service allowed us to upload an asset of FormatID ${w}, but it does not list it in its supported formats.`,new Error);return new x(d.assetName,d.contentType,[new A(d.assetURL,d.assetHash)])})}async function me(e,a){const t=(await y(e,a)).data.statusUrl;for(;;){const s=(await y(t,{query:{f:"json"},responseType:"json"})).data;switch(s.status){case"Completed":return y(s.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new c("async-convert3D-failed","asynchronous convert3D call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new c("async-convert3D-failed","asynchronous convert3D call failed (undefined response status)")}await Q(he)}}function we(e){return!!e.infoFor3D&&!!e.url}function I(e){const{infoFor3D:a}=e,t=U("model/gltf-binary",a.supportedFormats)??X("glb",a.supportedFormats);if(!t)throw new c(`${e.type}-layer:upload-failure`,"Layer does not support glb.",new Error);return t}const he=1e3;export{$e as uploadAssets};
